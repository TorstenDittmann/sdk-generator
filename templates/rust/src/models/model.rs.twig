#![allow(unused)]
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use serde_json::value::Value;
use super::*;

#[derive(Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
#[serde(untagged)]
pub enum EmptyOption<T> {
    Some(T),
    None {},
}


impl<T> From<EmptyOption<T>> for Option<T> {
    fn from(empty_option: EmptyOption<T>) -> Option<T> {
        match empty_option {
            EmptyOption::Some(option) => Some(option),
            EmptyOption::None {} => None,
        }
    }
}

impl<T> From<Option<T>> for EmptyOption<T> {
    fn from(option: Option<T>) -> EmptyOption<T> {
        match option {
            Some(option) => EmptyOption::Some(option),
            None {} => EmptyOption::None {},
        }
    }
}

impl<T> EmptyOption<T> {
    fn into_option(self) -> Option<T> {
        self.into()
    }
    fn as_option(&self) -> Option<&T> {
        match self {
            EmptyOption::Some(option) => Some(option),
            EmptyOption::None {} => None,
        }
    }
}

{% macro sub_schema(property) %}{% if property.sub_schema %}{% if property.type == 'array' %}Vec<{{property.sub_schema | caseUcfirst}}>{% else %}{{property.sub_schema | caseUcfirst}}{% endif %}{% else %}{{property.type | typeName}}{% endif %}{% endmacro %}
#[derive(Serialize, Deserialize, Debug)]
pub struct {{ definition.name | caseUcfirst }} {
{% for property in definition.properties %}
    {% if '$' in property.name %}    #[serde(rename(serialize = "{{ property.name | escapeKeyword | removeDollarSign }}", deserialize = "{{ property.name | escapeKeyword }}"))]
    {% endif %}
    pub {{ property.name | escapeKeyword | removeDollarSign }}: {% if property.required %}EmptyOption<{% endif %}{% if property.type == 'string' %}String{% elseif _self.sub_schema(property) == '&[&str]' %}Vec<String>{% else %}{{_self.sub_schema(property)}}{% endif %}{% if property.required %}>{% endif %},
{% endfor %}
{% if definition.additionalProperties %}
    pub data: HashMap<String, Value>,
{% endif %}
}